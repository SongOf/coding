一、二分查找

```java
// 二分查找 查找到即返回
public int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) { //考虑初始值low == high
            int mid = left + (right - left) >> 1; //细节
            if(nums[mid] == target) return mid;
            else if(nums[mid] > target) right = mid - 1;
            else left = mid + 1;
        }
        return -1;
}
```

```java
// 二分查找 左侧边界 [left, right) 左闭右开的形式
public int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意
    
    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    // target 比所有数都大
	if (left == nums.length) return -1;
	// target 比所有数都小
	return nums[left] == target ? left : -1;
}
```

```java
// 二分查找 右侧边界 [left, right) 左闭右开的形式
public int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;
    
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    if (left == 0) return -1;
    return nums[left-1] == target ? (left-1) : -1;
}
```

```java
//在排序数组中查找数字 二分查找边界的应用
class Solution {
    public int search(int[] nums, int target) {
        int left = left_bound(nums, target);
        int right = right_bound(nums, target);
        return left != -1 ? right - left + 1:0;
    }
}
```

```java
//0～n-1中缺失的数字
//二分查找
    class Solution {
       public int missingNumber(int[] nums) {
   
           int left = 0, right = nums.length - 1;
           while(left <= right) {
               int mid = left + (right - left) / 2;
               if(nums[mid] == mid) left = mid + 1;
               else right = mid - 1;
           }
           return left;
       }
   }
```
```java
// 二分查找 旋转数组的最小值 允许重复值
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if(numbers[mid] > numbers[right]) left = mid + 1; //mid一定在左侧有序数组中 +1不会错过最小元素
            else if(numbers[mid] < numbers[right]) right = mid; //mid一定在右侧有序数组中 目标区间[left, mid]
            else right --;
        }
        return numbers[left];
    }
```

一、DFS 存在类问题

```java
// 二维矩阵的路径 DFS + 备忘录
public class Solution {
    private int[][] dist = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    public boolean exist(char[][] board, String word) {
        int m = board.length;
        int n = board[0].length;
        boolean[][] mark = new boolean[m][n];
        char[] words = word.toCharArray();
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(board[i][j] == words[0] && dfs(board, i, j, words, 0, mark)) return true;
            }
        }
        return false;
    }
    
    public boolean dfs(char[][] board, int row, int col, char[] word, int index, boolean[][] mark) {
        if(index == word.length) return true;
        if(row < 0 || row >= board.length || col < 0 || col >= board[0].length || mark[row][col] ||  word[index] != board[row][col]) return false;
        mark[row][col] = true;
        boolean res = false;
        for(int i = 0; i < 4; i++) {
            int newRow = row + dist[i][0];
            int newCol = col + dist[i][1];
            res = res || dfs(board, newRow, newCol, word, index + 1, mark);
        }
        mark[row][col] = false;
        return res;
    }
}
```

一、BFS 最优类问题

```java
//二维矩阵 机器人运动范围 BFS + 备忘录
public class Solution1 {
    private static final int[][] dist = {{1, 0}, {0, 1}};
    public static class Node {
        private int row;
        private int col;
        public Node() {}
        public Node(int row, int col) {
            this.row = row;
            this.col = col;
        }
    }
    public int movingCount(int m, int n, int k) {
        boolean[][] mark = new boolean[m][n];
        LinkedList<Node> queue = new LinkedList<>();
        queue.offer(new Node(0, 0));
        int res = 1;
        mark[0][0] = true;
        while (!queue.isEmpty()) {
            Node cur = queue.poll();
            for (int i = 0; i < 2; i++) {
                int newRow = cur.row + dist[i][0];
                int newCol = cur.col + dist[i][1];
                if(newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && !mark[newRow][newCol] && !isLarger(newRow, newCol, k)) {
                    queue.offer(new Node(newRow, newCol));
                    res ++;
                    mark[newRow][newCol] = true;
                }
            }
        }
        return res;
    }
    public boolean isLarger(int row, int col, int k) {
        int sum = 0;
        while (row != 0) {
            sum += row % 10;
            row = row / 10;
        }
        while (col != 0) {
            sum += col % 10;
            col = col / 10;
        }
        return sum > k;
    }
}
```

回溯

```java
//树的路径和等于k的全部路径
class Solution {
    private int sum;
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        sum = 0;
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        pathSumCore(root, target, path, res);
        return res;
    }
    public void pathSumCore(TreeNode root, int target, List<Integer> path, List<List<Integer>> res) {
        if(root == null) return;

        sum += root.val;
        path.add(root.val);
        if(root.left == null && root.right == null && sum == target) {
            res.add(new ArrayList<>(path));
        }

        if(root.left != null) pathSumCore(root.left, target, path, res);
        if(root.right != null) pathSumCore(root.right, target, path, res);

        sum -= root.val;
        path.remove(path.size() - 1);
    }
}
```

二、树

```java
//树的先序遍历
public void preOrder(TreeNode root) {
    if(root == null) return;
    //root.val;
    preOrder(root.left);
    preOrder(root.right);
}
//基于树的先序遍历完成树的序列化和反序列化
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuffer sb = new StringBuffer();
        serializeCore(root, sb);
        return sb.toString();
    }
    public void serializeCore(TreeNode root, StringBuffer sb) {
        if(root == null) {
            sb.append("null" + ",");
            return;
        }
        sb.append(root.val + ",");
        serializeCore(root.left, sb);
        serializeCore(root.right, sb);
    }
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        LinkedList<String> nodes = new LinkedList<>(Arrays.asList(data.split(",")));
        return deserializeCore(nodes);
    }
    public TreeNode deserializeCore(LinkedList<String> nodes) {
        TreeNode root = null;
        String firstNode = nodes.getFirst();
        nodes.removeFirst();
        if(firstNode.equals("null")) return root;
        root = new TreeNode(Integer.parseInt(firstNode));
        root.left = deserializeCore(nodes);
        root.right = deserializeCore(nodes);
        return root;
    }
}
```

```java
//树的中序遍历
public void inOrder(TreeNode root) {
    if(root == null) return;
    preOrder(root.left);
    //root.val;
    preOrder(root.right);
}
//二叉搜索树的中序遍历 二叉搜索树转双向链表
public class Solution {
    private Node head;
    private Node lastNode;
    public Node treeToDoublyList(Node root) {
        if(root == null) return null;

        treeToDoublyListCore(root);
        head.left = lastNode;
        lastNode.right = head;
        return head;
    }
    public void treeToDoublyListCore(Node root) {
        if(root == null) return;

        treeToDoublyListCore(root.left);

        if(lastNode == null) {
            head = root;
        }
        else {
            lastNode.right = root;
            root.left = lastNode;
        }
        lastNode = root;

        treeToDoublyListCore(root.right);
    }
}
```

```java
//树的后序遍历
public void postOrder(TreeNode root) {
    if(root == null) return;
    preOrder(root.left);
    preOrder(root.right);
    //root.val;
}
//判断序列是否是二叉搜索树的后序遍历
    public boolean verifyPostorder(int[] postorder) {
        if(postorder == null) return false;

        int len = postorder.length;
        if(len == 0 || len ==1) return true;

        return verifyPostorderCore(postorder, 0, len - 1);
    }
    public boolean verifyPostorderCore(int[] postorder, int left, int right) {
        if(left >= right) return true;

        int rootValue = postorder[right];
        int start = left;
        while(start < right && postorder[start] < rootValue) start ++;
        for(int i = start; i < right; i ++) {
            if(postorder[i] < rootValue) return false;
        }
        //1 start == left
        //2 start == right
        //3 left < start < right
        return verifyPostorderCore(postorder, left, start - 1) && verifyPostorderCore(postorder, start, right - 1);
    }
```

```java
//树的层序遍历
    public int[] levelOrder(TreeNode root) {
        if(root == null) return new int[0];

        LinkedList<TreeNode> queue = new LinkedList<>();
        List<Integer> res = new ArrayList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            res.add(cur.val);
            if(cur.left != null) queue.offer(cur.left);
            if(cur.right != null) queue.offer(cur.right);
        }
        return res.stream().mapToInt(Integer::intValue).toArray();
    }
//树的层序遍历 + 按层操作
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;

        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> levelEles = new ArrayList<>();
            for(int i = 0; i < size; i ++) {
                TreeNode cur = queue.poll();
                levelEles.add(cur.val);
                if(cur.left != null) queue.offer(cur.left);
                if(cur.right != null) queue.offer(cur.right);
            }
            res.add(levelEles);
        }
        return res;
    }
//树的层序遍历 + 之字形顺序
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if(root == null) return res;

        LinkedList<TreeNode> stack = new LinkedList<>();
        LinkedList<TreeNode> stack1 = new LinkedList<>();
        stack.push(root);
        int level = 0;
        while(!stack.isEmpty()) {
            List<Integer> levelEles = new ArrayList<>();
            int size = stack.size();
            for(int i = 0; i < size; i ++) {
                TreeNode cur = stack.pop();
                levelEles.add(cur.val);
                if(level % 2 == 0) {
                    if(cur.left != null) stack1.push(cur.left);
                    if(cur.right != null) stack1.push(cur.right);
                }
                else {
                    if(cur.right != null) stack1.push(cur.right);
                    if(cur.left != null) stack1.push(cur.left);
                }
            }
            res.add(levelEles);
            level ++;
            LinkedList<TreeNode> tmp = stack;
            stack = stack1;
            stack1 = tmp;
        }
        return res;
    }
```

```java
//重建二叉树
//递归 + HashMap优化
public class Solution {
    private Map<Integer, Integer> indexMap;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        indexMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            indexMap.put(inorder[i], i);
        }
        return buildTreeCore(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }
    public TreeNode buildTreeCore(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        if(preStart > preEnd) return null;
        int val = preorder[preStart];
        TreeNode root = new TreeNode(val);
        int inLoc = indexMap.get(val);
        int len = inLoc - inStart;
        root.left = buildTreeCore(preorder, preStart + 1, preStart + len, inorder, inStart, inLoc - 1);
        root.right = buildTreeCore(preorder, preStart + len + 1, preEnd, inorder, inLoc + 1, inEnd);
        return root;
    }
}
```

```java
//迭代
```

```java
//判断树的子结构
	public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(B == null) return false;

        return isSubStructureCore(A, B);
    }
    public boolean isSubStructureCore(TreeNode A, TreeNode B) {
        if(A == null) return false;
        if(A.val == B.val && isSame(A, B)) {
            return true;
        }
        return isSubStructureCore(A.left, B) || isSubStructureCore(A.right, B);
    }
    public boolean isSame(TreeNode A, TreeNode B) {
        if(B == null) return true;
        if(A == null) return false;
        return A.val == B.val && isSame(A.left, B.left) && isSame(A.right, B.right);
    }
```

```java
//二叉搜索树的最近公共祖先
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;

        if(root.val <= p.val && root.val >= q.val || root.val >= p.val && root.val <= q.val) {
            return root;
        }
        if(root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        else {
            return lowestCommonAncestor(root.left, p, q);
        }
    }
```

```java
//二叉树的最近公共祖先
//递归形式
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root.val == p.val || root.val == q.val) {
            return root;
        }
        
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
```

```java
//二叉树的最近公共祖先
//非二叉树同样适用
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;

        List<TreeNode> path1 = new ArrayList<>();
        findPath(root, p, path1);
        List<TreeNode> path2 = new ArrayList<>();
        findPath(root, q, path2);
        int pos = 0;
        TreeNode tar = null;
        while (pos < path1.size() && pos < path2.size()) {
            if(path1.get(pos).val != path2.get(pos).val) break;
            tar = path1.get(pos);
            pos ++;
        }
        return tar;
    }
    public boolean findPath(TreeNode root, TreeNode tar, List<TreeNode> path) {
        if(root == null) return false;

        path.add(root);
        if(root.val == tar.val || findPath(root.left, tar, path) || findPath(root.right, tar, path)) {
            return true;
        }
        else {
            path.remove(path.size() - 1);
            return false;
        }
    }
```

```java
//二叉搜索树的第k大节点
//中序遍历
class Solution {
    private int res, k;
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        kthLargestCore(root);
        return res;
    }
    public void kthLargestCore(TreeNode root) {
        if(root == null) return;
        kthLargestCore(root.right);
        if(this.k == 0) return;
        this.k--;
        if(this.k == 0) this.res = root.val;
        kthLargestCore(root.left);
    }
}
```

三、动态规划

```
//剪绳子
//当 i < 2时
//dp[0] = 1
//dp[1] = 1
//当 i >= 2时
//dp[i] = max{ dp[i], j * (i - j), j * dp[i - j]}
//⼀个数分解成 j 和 i - j 两个数字，或者分解成 j 和 更多的分解数 ， 更多的分解数 即是 dp[i-j] ，由于
//dp[i-j] 下标⼩于 i ，所以 dp[i-j] 在计算 dp[i] 的时候⼀定计算出来了。

	public int cuttingRope(int n) {
        if(n < 2) return -1;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j < i; j++) {
                dp[i] = Math.max(dp[i], j * Math.max(i - j, dp[i - j]));
            }
        }
        return dp[n];
    }
```

```java
//连续子数组的最大和
//动态规划
//dp[0] = nums[0]
//dp[i] = dp[i - 1] + nums[i]   if dp[i - 1] > 0
//      = nums[i]               if dp[i - 1] <= 0
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0) {
            return 0;
        }
        int length = nums.length;
        int[] dp = new int[length];
        dp[0] = nums[0];
        int maxSum = nums[0];
        for (int i = 1; i < length; i++) {
            if(dp[i - 1] > 0) dp[i] = dp[i - 1] + nums[i];
            else dp[i] = nums[i];
            if(dp[i] > maxSum) maxSum = dp[i];
        }
        return maxSum;
    }
}
//优化空间复杂度 dp[i] 只与 dp[i - 1] 和 nums[i] 有关
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums == null || nums.length == 0) {
            return 0;
        }
        int length = nums.length;
        int dp = nums[0];
        int maxSum = nums[0];
        for (int i = 1; i < length; i++) {
            if(dp > 0) dp = dp + nums[i];
            else dp = nums[i];
            if(dp > maxSum) maxSum = dp;
        }
        return maxSum;
    }
}
```

```java
//把数字翻译成字符串
//0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”,一个数字可能有多个翻译
//0 <= num < 231
//12258
//5 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
//f(i) 表示i位以及右边的数字的翻译数
//f(i) = f(i + 1) + f(i + 2) 当i + 1 <= length - 1 且 10 <= f(i + 1)f(i + 2) <= 25
//     = f(i + 1)
public class Solution {
    public int translateNum(int num) {
        return translateNumCore(num);
    }
    public int translateNumCore(int num) {
        if(num >= 0 && num <= 9) return 1;
        int tmp = num % 100;
        if(tmp > 9 && tmp < 26) return translateNumCore(num / 10) + translateNumCore(num / 100);
        else return translateNumCore(num / 10);
    }
}
//礼物的最大值
//在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到
//到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物
//dp[0][0] = grid[0][0]
//dp[0][j] = dp[0][j - 1] + grid[0][j] 当 i == 0时
//dp[i][0] = dp[i - 1][0] + grid[i][0] 当 j == 0时
//dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
class Solution {
    public int maxValue(int[][] grid) {
        if(grid == null) return 0;
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        for(int i = 0; i < m; i ++) {
            Arrays.fill(dp[i], 0);
        }
        for(int i = 0; i < m; i ++) {
            if(i == 0) dp[0][0] = grid[0][0];
            else dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for(int j = 1; j < n; j ++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for(int i = 1; i < m; i ++) {
            for(int j = 1; j < n; j ++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[m - 1][n - 1];
    }
}
//优化空间复杂度
class Solution {
    public int maxValue(int[][] grid) {
        if(grid == null) return 0;
        int m = grid.length;
        int n = grid[0].length;
        int left;
        int top;
        int[] dp = new int[n];
        for(int i = 0; i < m; i ++) {
            for(int j = 0; j < n; j ++) {
                left = 0;
                top = 0;
                if(i > 0) top = dp[j];
                if(j > 0) left = dp[j - 1];
                dp[j] = Math.max(left, top) + grid[i][j];
            }
        }
        return dp[n - 1];
    }
}
```

```java
//把数字翻译成字符串
//动态规划 f(i)以i位置字符结尾的字符串的翻译数量
//f(i) = f(i - 1) + f(i - 2) 如果10 <= num(i - 2, i - 1) <= 25
//     = f(i - 1) 其他情况
//递归实现
class Solution {
    public int translateNum(int num) {
        if(num < 0) return 0;
        if(num >= 0 && num <= 9) return 1;
        int tmp = num % 100;
        if(tmp < 26 && tmp > 9) return translateNum(num / 100) + translateNum(num / 10);
        else return translateNum(num / 10);
    }
}
//非递归实现

```

```java
//丑数
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for(int i = 2; i <= n; i++) {
            int tmp2 = dp[p2] * 2;
            int tmp3 = dp[p3] * 3;
            int tmp5 = dp[p5] * 5;
            dp[i] = Math.min(Math.min(tmp2, tmp3), tmp5);
            if(dp[i] == tmp2) p2++;
            if(dp[i] == tmp3) p3++;
            if(dp[i] == tmp5) p5++;
        }
        return dp[n];
    }
}
```
四、双指针

```
//左右双指针
//调整数组使得左奇右偶
    public int[] exchange(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        int tmp;
        while(left < right) {
            while(left < right && nums[left] % 2 == 1) left ++;
            while(left < right && nums[right] % 2 == 0) right --;
            if(left < right) {
                tmp = nums[left];
                nums[left] = nums[right];
                nums[right] = tmp;
            }
        }
        return nums;
    }
```

```
//快慢双指针
//链表倒数第k个节点
    public ListNode getKthFromEnd(ListNode head, int k) {
        if(head == null || k == 0) return null;
        ListNode fast = head;
        ListNode slow = head;
        while(k > 0) {
            if(fast == null) fast = head;
            fast = fast.next;
            k --;
        }
        while(fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
```

```java
//最长不含重复字符的子字符串
//"abcabcbb"
//3
//双指针
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null || s.length() == 0) return 0;
        int length = s.length();
        char[] chs = s.toCharArray();
        int left = -1;
        HashMap<Character, Integer> locs = new HashMap<>(); //key 记录出现的字符 value记录字符的最后一次出现位置
        int res = -1;
        for(int right = 0; right < length; right ++) {
            if(locs.containsKey(chs[right])) {
                left = Math.max(left, locs.get(chs[right]));
            }
            locs.put(chs[right], right);
            res = Math.max(res, right - left);
        }
        return res;
    }
}
```

```java
//和为s的连续正数序列
//双指针
class Solution {
    public int[][] findContinuousSequence(int target) {
        List<int[]> res = new ArrayList<>();
        int sum;
        for(int left = 1, right = 2; left < right;) {
            sum = (left + right) * (right - left + 1) / 2;
            if(sum == target) {
                int[] q = new int[right - left + 1];
                for(int i = left; i <= right; i++) {
                    q[i - left] = i;
                }
                res.add(q);
                left++;
            }else if(sum < target) {
                right++;
            }else {
                left++;
            }
        }
        return res.toArray(new int[res.size()][]);
    }
}
```

```java
//滑动窗口的最大值
//k滑动窗口
//基于优先队列
public class Solution {
    public static class Node implements Comparable<Node> {
        private int val;
        private int index;
        private Node() {}
        private Node(int val, int index) {
            this.index = index;
            this.val = val;
        }
        @Override
        public int compareTo(Node node) {
            return this.val != node.val ? (node.val - this.val) : (node.index - this.index);
        }
    }
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || nums.length == 0 || k <=0 || k > nums.length) {
            return new int[0];
        }
        int length = nums.length;
        int[] res = new int[length - k + 1];
        int pos = 0;
        PriorityQueue<Node> queue = new PriorityQueue<>();
        for(int i = 0; i < k; i++) {
            queue.offer(new Node(nums[i], i));
        }
        if(!queue.isEmpty()) res[pos++] = queue.peek().val;
        for(int i = k; i < length; i++) {
            queue.offer(new Node(nums[i], i));
            while (!queue.isEmpty() && queue.peek().index <= i - k) {
                queue.poll();
            }
            if(!queue.isEmpty()) res[pos++] = queue.peek().val;
        }
        return res;
    }
}

//基于单调队列
public class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums == null || nums.length == 0 || k <= 0 || k > nums.length) {
            return new int[0];
        }
        int length = nums.length;
        int[] res = new int[length - k + 1];
        int pos = 0;
        LinkedList<Integer> queue = new LinkedList<>();
        for(int i = 0; i < k; i++) {
            while(!queue.isEmpty() && nums[i] >= nums[queue.getLast()]) {
                queue.removeLast();
            }
            queue.add(i);
        }
        res[pos++] = nums[queue.getFirst()];
        for(int i = k; i < length; i++) {
            while (!queue.isEmpty() && nums[i] >= nums[queue.getLast()]) {
                queue.removeLast();
            }
            queue.add(i);
            while(!queue.isEmpty() && queue.getFirst() <= i - k) {
                queue.removeFirst();
            }
            res[pos++]=nums[queue.getFirst()];
        }
        return res;
    }
}
```

四、位运算

```java
// n & (n - 1) 将n的最右边的1转成0
//计算n的1的个数
public int hammingWeight(int n) {
    int res = 0;
    while(n != 0) {
        res ++;
        n = n & (n - 1);
    }
    return res;
}
```

```java
//快次幂
//-100.0 <= x <= 100.0
//-2^31 <= n <= 2^31 -1
	public double myPow(double x, int n) {
        if(x == 0) return 0;
        long exp = n; //防止溢出
        double res = 1.0;
        if(exp < 0) {
            exp = - exp;
            x = 1 / x;
        }
        while (exp > 0) {
            if((exp & 1) == 1) res *= x;
            x = x * x;
            exp = exp >> 1;
        }
        return res;
    }
```

```java
//1～n 整数中 1 出现的次数
//1004 1014 1024为例 分析十位的情况：
//1、cur == 0 res += high * exp
//2、cur == 1 res += high * exp + low + 1
//即0 - 1014 可看做 0 - 1004 和 1004 - 1014
//3、cur >= 2 high * exp + exp
//即0 - 1024 可看做 0 - 1004 和 1004 - 1024
public class Solution {
    public int countDigitOne(int n) {
        int high = n;
        int low = 0;
        int cur = 0;
        int res = 0;
        int exp = 1;
        while (high != 0 || cur != 0) {
            cur = high % 10;
            high = high / 10;
            if(cur == 0) res += high * exp;
            else if(cur == 1) res += high * exp + low + 1;
            else res += high * exp + exp;
            low = exp * cur + low;
            exp = exp * 10;
        }
        return res;
    }
}
```

```java
//找出数组中两个只出现一次的数字a、b 其它数组都出现两次
//1、全部元素异或 得到a和b的异或值c
//2、找到c的非0位置d
//3、根据位置d分组 位置d为1的为一组 位置d为0的为一组
class Solution {
    public int[] singleNumbers(int[] nums) {
        if(nums == null || nums.length < 2) return null;

        int axorb = 0;
        for(int i = 0; i < nums.length; i++) {
            axorb ^= nums[i];
        }

        int exp = 1;
        while((exp & axorb) == 0) exp <<= 1;

        int resA = 0, resB = 0;
        for(int i = 0; i < nums.length; i++) {
            if((exp & nums[i]) == 0) resA ^= nums[i];
            else resB ^= nums[i];
        }
        return new int[]{resA, resB};
    }
}
```

```java
//数组中数字出现的次数
//如果一个数字出现3次，它的二进制每一位也出现的3次。
//如果把所有的出现三次的数字的二进制表示的每一位都分别加起来，那么每一位都能被3整除。 
//把数组中所有的数字的二进制表示的每一位都加起来。
//如果某一位能被3整除，那么这一位对只出现一次的那个数的这一位肯定为0。
//如果某一位不能被3整除，那么只出现一次的那个数字的该位置一定为1.
class Solution {
    public int singleNumber(int[] nums) {
        int[] bits = new int[32];
        Arrays.fill(bits, 0);
        for(int i = 0; i < nums.length; i++) {
            int exp = 1;
            for(int j = 0; j < 32; j++) {
                bits[j] += (nums[i] & exp) == 0 ? 0:1;
                exp <<= 1;
            }
        }
        int res = 0;
        for(int i = 31; i >= 0; i--) {
            res <<= 1;
            res |= (bits[i] % 3);
        }
        return res;
    }
}
```

```java
//不用加减乘除做加法
//加法运算 a + b
//（a & b) << 1 得到a + b的进位
//（a ^ b) 得到a + b的非进位部分
class Solution {
    public int add(int a, int b) {
        while(b != 0) {
            int c = (a & b) << 1;
            a = a ^ b;
            b = c;
        }
        return a;
    }
}
```

```java
//判断n是2的幂
//n & (n - 1) == 0
//若n是2的幂
//i % n = i & (n - 1)
```

五、递归

```
//O(10^10) 性能很差
//打印从1到最大的n位数 -- 大数打印
public class Solution {

    private char[] num;
    private List<Integer> ans;

    public int[] printNumbers(int n) {
        num = new char[n];
        ans = new ArrayList<>();
        dfs(0, n);
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }

    private void dfs(int index, int n) {
        if(index == n) {
            String numStr = String.valueOf(num);
            int tmp = Integer.parseInt(numStr);
            if(tmp != 0) ans.add(tmp);
            return;
        }
        for(int i = '0'; i <= '9'; i++) {
            num[index] = (char) i;
            dfs(index + 1, n);
        }
    }
}
```

六、 栈

```java
//栈的压入、弹出序列
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        if(pushed == null || popped == null) return false;

        int pushedLength = pushed.length;
        int poppedLength = popped.length;
        if(pushedLength == 0 && poppedLength == 0) return true;
        if(pushedLength == 0 || poppedLength == 0) return false;

        LinkedList<Integer> stack = new LinkedList<>();
        int pos1 = 0;
        int pos2 = 0;
        while(pos1 < pushedLength) {
            stack.push(pushed[pos1]);
            while(!stack.isEmpty() && stack.peek() == popped[pos2]) {
                stack.pop();
                pos2 ++;
            }
            pos1 ++;
        }
        return stack.isEmpty();
    }
```

六、 队列

七、链表

```java
//链表的k翻转
public class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode hair = new ListNode(-1);
        hair.next = head;

        ListNode pre = hair;
        while(head != null) {
            ListNode tail = pre;
            for(int i = 0; i < k; i ++) {
                tail = tail.next;
                if(tail == null) return hair.next;
            }
            ListNode nxt = tail.next;
            ListNode[] reversed = reverse(head, tail);
            head = reversed[0];
            tail = reversed[1];
            pre.next = head;
            tail.next = nxt;
            pre = tail;
            head = pre.next;
        }
        return hair.next;
    }
    public ListNode[] reverse(ListNode head, ListNode tail) {
        ListNode prev = null;
        ListNode cur = head;
        while(prev != tail) {
            ListNode nxt = cur.next;
            cur.next = prev;
            prev = cur;
            cur = nxt;
        }
        return new ListNode[]{tail, head};
    }
}
//链表求和
//反向存储
//1234 4 -> 3 -> 2 -> 1
//正向存储
//1234 1 -> 2 -> 3 -> 4
public class Solution {
    //反向存储
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;

        int l1Len = getListLength(l1);
        int l2Len = getListLength(l2);
        if(l1Len > l2Len) return addTwoNumbersCore(l1, l2);
        else return addTwoNumbersCore(l2, l1);
    }
    //正向存储
    public ListNode addAB(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;

        l1 = reverse(l1);
        l2 = reverse(l2);
        int l1Len = getListLength(l1);
        int l2Len = getListLength(l2);
        if(l1Len > l2Len) return addTwoNumbersCore(l1, l2);
        else return addTwoNumbersCore(l2, l1);
    }
    public int getListLength(ListNode l) {
        int len = 0;
        while (l != null) {
            len ++;
            l = l.next;
        }
        return len;
    }
    public ListNode reverse(ListNode l) {
        ListNode pre = null;
        while (l != null) {
            ListNode nxt = l.next;
            l.next = pre;
            pre = l;
            l = nxt;
        }
        return pre;
    }
    public ListNode addTwoNumbersCore(ListNode l1, ListNode l2) {
        ListNode head = l1;
        int c = 0;
        int sum;
        ListNode pre = null;
        while (l1 != null && l2 != null) {
            sum = c + l1.val + l2.val;
            c = sum / 10;
            l1.val = sum % 10;
            pre = l1;
            l1 = l1.next;
            l2 = l2.next;
        }
        while (l1 != null) {
            sum = c + l1.val;
            c = sum / 10;
            l1.val = sum % 10;
            pre = l1;
            l1 = l1.next;
        }
        if(c != 0) {
            pre.next = new ListNode(c);
        }
        return head;
    }
}
```

八、字符串操作

```java
//字符串全排列
public class Solution {
    private Set<String> res = new HashSet<>();
    public String[] permutation(String s) {
        if(s != null && s.length() >= 1) {
            char[] chs = s.toCharArray();
            permutationCore(chs, 0, chs.length - 1);
        }
        return new ArrayList<>(res).toArray(new String[res.size()]);
    }
    public void permutationCore(char[] chs, int start, int end) {
        if(start == end) {
            res.add(new String(chs));
            return;
        }
        char ch;
        for(int i = start; i <= end; i ++) {
            if(i == start || chs[i] != chs[start]) {
                ch = chs[i];
                chs[i] = chs[start];
                chs[start] = ch;
                permutationCore(chs, start + 1, end);
                ch = chs[i];
                chs[i] = chs[start];
                chs[start] = ch;
            }
        }
    }
}
```
```java
//最长不重复子串
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s == null) return 0;
        char[] chs = s.toCharArray();
        int left = 0, right = 0;
        int maxLen = 0;
        HashMap<Character, Integer> lastLoc = new HashMap<>();
        while(right < chs.length) {
            if(lastLoc.containsKey(chs[right])) {
                left = Math.max(left, lastLoc.get(chs[right]) + 1);
            }
            lastLoc.put(chs[right], right);
            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }
        return maxLen;
    }
}
```

```java
//翻转单词顺序
class Solution {
    public String reverseWords(String s) {
        if(s == null) return null;
        
        int length = s.length();
        StringBuilder sb = new StringBuilder();
        int start = length - 1;
        while(start >= 0 && s.charAt(start) == ' ') start--;
        int end = start;
        while(start >= 0) {
            while(start >= 0 && s.charAt(start) != ' ') start--;
            sb.append(s.substring(start + 1, end + 1));
            while(start >= 0 && s.charAt(start) == ' ') start--;
            if(start >= 0) sb.append(' ');
            end = start;
        }
        return sb.toString();
    }
}
```

九、排序算法

```java
//快速排序
//最小的k个数
public class Solution {
    //快速排序
    public void quickSort(int[] arr) {
        if(arr == null || arr.length == 0) return;
        quickSortCore(arr, 0, arr.length - 1);
    }
    public void quickSortCore(int[] arr, int start, int end) {
        if (start < end) {
            int p = partition(arr, start, end);
            quickSortCore(arr, start, p - 1);
            quickSortCore(arr, p + 1, end);
        }
    }
	//最小的k个数
    public int[] getLeastNumbers(int[] arr, int k) {
        if(arr == null || arr.length == 0 || k <= 0) return new int[0];
        int start = 0;
        int end = arr.length - 1;
        while (start < end) {
            int p = partition(arr, start, end);
            if(p > k - 1) end = p - 1;
            else if(p < k - 1) start = p + 1;
            else break;
        }
        int[] res = new int[k];
        System.arraycopy(arr, 0, res, 0, k);
        return res;
    }
    public int partition(int[] arr, int start, int end) {
        int p = arr[start];
        while (start < end) {
            while (start < end && arr[end] >= p) end --;
            arr[start] = arr[end];
            while (start < end && arr[start] <= p) start ++;
            arr[end] = arr[start];
        }
        arr[start] = p;
        return start;
    }
}
//把数组排成最小的数
//输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个
//[3,30,34,5,9]
//"3033459"
//0 < nums.length <= 100
public class Solution {
    public String minNumber(int[] nums) {
        if(nums == null || nums.length == 0) return "";
        String[] numsStr = new String[nums.length];
        for (int i = 0; i < nums.length; i++) {
            numsStr[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(numsStr, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < numsStr.length; i++) {
            sb.append(numsStr[i]);
        }
        return sb.toString();
    }
}
```

```java
//归并排序
//数组中的逆序对:归并排序解法
public class Solution {
    private int res;
    public int reversePairs(int[] nums) {
        res = 0;
        mergeSort(nums, 0, nums.length - 1);
        return res;
    }
    public void mergeSort(int[] nums, int start, int end) {
        int mid = start + ((end - start) >> 1);
        if (start < end) {
            mergeSort(nums, start, mid);
            mergeSort(nums, mid + 1, end);
            merge(nums, start, mid, end);
        }
    }
    public void merge(int[] nums, int start, int mid, int end) {
        int[] tmp = new int[end - start + 1];
        int cur = 0;
        int leftPos = start, rightPos = mid + 1;

        while (leftPos <= mid && rightPos <= end) {
            if (nums[leftPos] <= nums[rightPos]) {
                tmp[cur++] = nums[leftPos++];
            } else {
                //用来统计逆序对的个数
                res += (mid - leftPos + 1);
                tmp[cur++] = nums[rightPos++];
            }
        }
        while (leftPos <= mid) {
            tmp[cur++] = nums[leftPos++];
        }
        while (rightPos <= end) {
            tmp[cur++] = nums[rightPos++];
        }
        for (int k = 0; k < tmp.length; k++) {
            nums[k + start] = tmp[k];
        }
    }
}
```

```java
//堆排序
	public void heapSort(int[] nums) {
        int len = nums.length - 1;
        buildMaxHeap(nums, len);
        for (int i = len; i >= 1; i--) {
            swap(nums, i, 0);
            len -= 1;
            maxHeapify(nums, 0, len);
        }
    }
    public void buildMaxHeap(int[] nums, int len) {
        for (int i = len / 2; i >= 0; i--) {
            maxHeapify(nums, i, len);
        }
    }
    public void maxHeapify(int[] nums, int root, int len) {
        while ((root << 1) + 1 <= len) {
            int lson = (root << 1) + 1;
            int rson = (root << 1) + 2;
            int large = root;
            if(lson <= len && nums[lson] > nums[large]) {
                large = lson;
            }
            if(rson <= len && nums[rson] > nums[large]) {
                large = rson;
            }
            if(large != root) {
                swap(nums, root, large);
                root = large;
            }
            else {
                break;
            }
        }
    }
    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
```

```java
//把数组排成最小的数
// x + y < y + x 则x应该排在y的左侧
//x + y > y + x 则x应该排在y的右侧
class Solution {
    public String minNumber(int[] nums) {
        String[] numstrs = new String[nums.length];
        StringBuilder res = new StringBuilder();
        for(int i = 0; i < nums.length; i++) {
            numstrs[i] = String.valueOf(nums[i]);
        }
        Arrays.sort(numstrs, (x, y) -> ((x + y).compareTo(y + x)));
        for(int i = 0; i < numstrs.length; i++) {
            res.append(numstrs[i]);
        }
        return res.toString();
    }
}
```

十、大数据

```java
//求中位数 5 亿个数 数据排序后，位置在最中间的数就是中位数
//当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值
//双堆法：大顶堆，小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1
//适用于数据量较小的情况，5亿个数每个数字占4B 需要2G内存 若内存不足就需要分治法
public class MedianFinder {
    private PriorityQueue<Integer> maxHeap;
    private PriorityQueue<Integer> minHeap;
    /** initialize your data structure here. */
    public MedianFinder() {
        maxHeap = new PriorityQueue<>((o1, o2) -> o2 - o1);
        minHeap = new PriorityQueue<>();
    }
    public void addNum(int num) {
        if(maxHeap.size() == 0 || maxHeap.peek() > num) {
            maxHeap.add(num);
        }else {
            minHeap.add(num);
        }
        if(maxHeap.size() - minHeap.size() > 1) {
            minHeap.add(maxHeap.poll());
        }else if(minHeap.size() - maxHeap.size() > 1){
            maxHeap.add(minHeap.poll());
        }
    }
    public double findMedian() {
        if(maxHeap.size() == minHeap.size()) return (maxHeap.peek() + minHeap.peek()) / 2.0;
        else if(maxHeap.size() > minHeap.size()) return maxHeap.peek();
        else return minHeap.peek();
    }
}
//分治法
分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。

对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。

提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。

对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。

注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。
```

